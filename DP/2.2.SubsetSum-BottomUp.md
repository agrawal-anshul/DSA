# Subset Sum Problem: How to list Out the subsets

## 1. Problem Statement

Given a set of `n` positive integers and a target sum `S`, determine whether there is a **subset** of the numbers that adds up to `S`. If so, **list all such subsets**.

---

## 2. Core Intuition for Subset Extraction

### What the DP Table Tells Us:

The DP table tells us whether a sum `j` is **possible** using the first `i` elements.

* `dp[i][j] = true` means that a subset of the first `i` items **can form sum `j`**

### How Do We Extract Subsets?

To find actual subsets:

* Start from `dp[n][S] == true`
* Reconstruct the decisions that **led to this state**
* At each step, we ask:

  1. Did we **exclude** the current item → came from `dp[i-1][j]`
  2. Did we **include** the current item → came from `dp[i-1][j - arr[i-1]]`
* If both are true, we must **explore both paths**
* Once `sum == 0`, we've found a valid subset

### Key Idea:

You are tracing **valid paths backward** from `dp[n][target]` to `dp[0][0]`, recording the numbers included along the way.

---

## 3. DP Table Construction Code (C++)

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Build the DP table to solve subset sum problem
vector<vector<bool>> buildDP(const vector<int>& arr, int sum) {
    int n = arr.size();
    vector<vector<bool>> dp(n + 1, vector<bool>(sum + 1, false));

    // Base case: sum 0 is always possible (empty subset)
    for (int i = 0; i <= n; ++i)
        dp[i][0] = true;

    // Fill the table
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= sum; ++j) {
            if (arr[i - 1] > j) {
                dp[i][j] = dp[i - 1][j];
            } else {
                dp[i][j] = dp[i - 1][j] || dp[i - 1][j - arr[i - 1]];
            }
        }
    }
    return dp;
}
```

---

## 4. Subset Backtracking Code

```cpp
// Recursively backtrack and collect subsets
void findSubsets(int i, int sum, const vector<int>& arr, 
                 const vector<vector<bool>>& dp, vector<int>& current, vector<vector<int>>& result) {
    if (sum == 0) {
        result.push_back(current);
        return;
    }
    if (i == 0) return;

    // Exclude current item
    if (dp[i - 1][sum]) {
        findSubsets(i - 1, sum, arr, dp, current, result);
    }
    // Include current item
    if (sum >= arr[i - 1] && dp[i - 1][sum - arr[i - 1]]) {
        current.push_back(arr[i - 1]);
        findSubsets(i - 1, sum - arr[i - 1], arr, dp, current, result);
        current.pop_back(); // backtrack
    }
}
```

---

## 5. Main Function

```cpp
int main() {
    vector<int> arr = {3, 4, 5};
    int target_sum = 9;

    // Step 1: Build DP table
    vector<vector<bool>> dp = buildDP(arr, target_sum);

    // Step 2: Check if subset exists
    if (!dp[arr.size()][target_sum]) {
        cout << "No subset with given sum found." << endl;
        return 0;
    }

    // Step 3: Find all subsets
    vector<vector<int>> result;
    vector<int> current;
    findSubsets(arr.size(), target_sum, arr, dp, current, result);

    // Step 4: Print all subsets
    cout << "Subsets that sum to " << target_sum << ":\n";
    for (auto& subset : result) {
        for (int num : subset) {
            cout << num << " ";
        }
        cout << endl;
    }
    return 0;
}
```

---

## 6. Example Output

For `arr = [3, 4, 5]`, `target_sum = 9`, possible output:

```
Subsets that sum to 9:
5 4
4 5
```

---

## 7. Complexity

* Time Complexity: O(n \* sum) for DP + exponential for backtracking
* Space Complexity: O(n \* sum) + recursion stack

---

## 8. Summary

* Use DP table to determine whether a sum is possible
* Use recursion to backtrack and collect all valid subsets
* Intuition: treat each `dp[i][j]` as a point with two options — take or skip the current item
* Base condition is reaching sum 0

This structure is ready for use in interviews or as a template in your OneNote.
