# Subset Sum Problem

## 1. Problem Overview

### Statement:

Given a list of `n` positive integers and a target sum `S`, determine if there is any subset of the numbers that adds up to `S`.

> This is a decision problem:
>
> * Answer is `true` or `false`

### Example Input:

```
arr = [3, 4, 5]
target_sum = 9
```

### Objective:

Find whether any subset of `arr` sums exactly to 9.

---

## 2. Dynamic Programming Approach (Bottom-Up)

### Definition:

We construct a table `dp[i][j]` where:

* `i` = number of elements considered (from 0 to n)
* `j` = target sum from 0 to S
* `dp[i][j] = true` if we can make sum `j` using the first `i` elements

### Table Dimensions:

* Rows: `n + 1`
* Columns: `target_sum + 1`

### Base Case Initialization:

* `dp[0][0] = true` → We can always make sum 0 with 0 items
* `dp[0][j] = false` for `j > 0` → Cannot make non-zero sum with no items

### Transition Formula:

For each element `arr[i-1]` and sum `j`:

1. **Exclude the current item:**

```
dp[i][j] = dp[i-1][j]
```

2. **Include the item if it fits:**

```
if (j >= arr[i-1]) then
    dp[i][j] = dp[i-1][j] || dp[i-1][j - arr[i-1]]
```

We set `dp[i][j]` to `true` if either choice leads to the sum `j`.

---

## 3. Example Walkthrough

### Input:

```
arr = [3, 4, 5]
target_sum = 9
```

We will create a DP table with 4 rows (0-3 items) and 10 columns (0-9 sums).

### Step-by-Step Table Filling:

#### Initial Table (i = 0):

```
       j →   0   1   2   3   4   5   6   7   8   9
     i ↓
0         [ T   F   F   F   F   F   F   F   F   F ]
```

* Only sum 0 is possible with 0 items

#### Row 1 (Item = 3):

```
j = 0: true (carry over)
j = 3: true (take 3)
```

```
1         [ T   F   F   T   F   F   F   F   F   F ]
```

#### Row 2 (Item = 4):

```
j = 0: true
j = 3: true (from above)
j = 4: true (take 4)
j = 7: true (3+4)
```

```
2         [ T   F   F   T   T   F   F   T   F   F ]
```

#### Row 3 (Item = 5):

```
j = 0: true
j = 3: true
j = 4: true
j = 5: true (take 5)
j = 7: true
j = 8: true (3+5)
j = 9: true (4+5)
```

```
3         [ T   F   F   T   T   T   F   T   T   T ]
```

### Final DP Table:

```
       j →   0   1   2   3   4   5   6   7   8   9
     i ↓
0         [ T   F   F   F   F   F   F   F   F   F ]
1         [ T   F   F   T   F   F   F   F   F   F ]
2         [ T   F   F   T   T   F   F   T   F   F ]
3         [ T   F   F   T   T   T   F   T   T   T ]
```

---

## 4. Final Answer

We look at `dp[n][S] = dp[3][9]`

* It is `true`
* So, there **exists** a subset that adds to 9

### Subsets (not tracked in table, but examples):

* \[4, 5]
* \[3, 4, 2] (if more items were present)

---

## 5. Complexity Analysis

* **Time Complexity:** `O(n * S)` where `n = number of items`, `S = target sum`
* **Space Complexity:** `O(n * S)` → can be optimized to `O(S)` using 1D array if backtracking is not needed

---

## 6. Key Takeaways

* Use `dp[i][j]` to represent decisions up to index `i` for sum `j`
* Always initialize `dp[0][0] = true`
* At each step, consider: can we make sum `j` by taking or skipping the current item?
* This is the foundation for more advanced problems like:

  * Partition Equal Subset Sum
  * Count of Subsets with Given Sum
  * Target Sum
